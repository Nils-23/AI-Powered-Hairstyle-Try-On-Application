import { type NextRequest, NextResponse } from "next/server"
import Replicate from "replicate"
import type { ProcessingResult } from "@/types"

// Initialize Replicate client
const replicate = new Replicate({
  auth: process.env.REPLICATE_API_TOKEN,
})

// Validate environment variables
if (!process.env.REPLICATE_API_TOKEN) {
  console.error("REPLICATE_API_TOKEN is not set in environment variables")
}

export async function POST(request: NextRequest) {
  try {
    // Check if API token is available
    if (!process.env.REPLICATE_API_TOKEN) {
      console.error("Replicate API token not configured")
      return NextResponse.json({ success: false, error: "AI service temporarily unavailable" }, { status: 503 })
    }

    const formData = await request.formData()
    const image = formData.get("image") as File
    const hairstyleId = formData.get("hairstyleId") as string

    if (!image || !hairstyleId) {
      return NextResponse.json({ success: false, error: "Missing image or hairstyle selection" }, { status: 400 })
    }

    // Validate file type and size
    const allowedTypes = ["image/jpeg", "image/jpg", "image/png", "image/webp"]
    if (!allowedTypes.includes(image.type)) {
      return NextResponse.json(
        { success: false, error: "Invalid file type. Please use JPEG, PNG, or WebP." },
        { status: 400 },
      )
    }

    if (image.size > 5 * 1024 * 1024) {
      return NextResponse.json({ success: false, error: "File too large. Maximum size is 5MB." }, { status: 400 })
    }

    // Convert image to base64 for Replicate
    const imageBuffer = await image.arrayBuffer()
    const imageBase64 = `data:${image.type};base64,${Buffer.from(imageBuffer).toString("base64")}`

    // Get hairstyle reference image based on selection
    const hairstylePrompts = {
      "classic-fade": "professional classic fade haircut, short sides, clean lines, modern barbershop style",
      "modern-quiff": "stylish modern quiff hairstyle, textured top, voluminous, contemporary men's cut",
      "textured-crop": "textured crop haircut, natural texture, short length, trendy modern style",
      "long-layers": "long layered hairstyle, flowing layers, natural movement, shoulder length",
      "curly-top": "curly top fade, natural curls on top, faded sides, textured curly hair",
    }

    const stylePrompt =
      hairstylePrompts[hairstyleId as keyof typeof hairstylePrompts] || hairstylePrompts["classic-fade"]

    console.log(`Processing hairstyle: ${hairstyleId} for user image`)

    try {
      // Use Replicate's face swap or hair generation model
      // Using a popular face editing model that can handle hairstyle changes
      const output = await replicate.run(
        "tencentarc/photomaker:ddfc2b08d209f9fa8c1eca692712918bd449f695dabb4a958da31802a9570fe4",
        {
          input: {
            input_image: imageBase64,
            prompt: `portrait photo of a person with ${stylePrompt}, high quality, professional photography, good lighting, sharp focus`,
            negative_prompt:
              "blurry, low quality, distorted, deformed, bad anatomy, bad proportions, extra limbs, cloned face, disfigured, out of frame",
            num_steps: 50,
            style_strength_ratio: 20,
            num_outputs: 1,
            guidance_scale: 5,
            seed: Math.floor(Math.random() * 1000000),
          },
        },
      )

      // Handle different output formats from Replicate
      let resultImageUrl: string

      if (Array.isArray(output)) {
        resultImageUrl = output[0] as string
      } else if (typeof output === "string") {
        resultImageUrl = output
      } else if (output && typeof output === "object" && "image" in output) {
        resultImageUrl = (output as any).image
      } else {
        throw new Error("Unexpected output format from AI model")
      }

      if (!resultImageUrl) {
        throw new Error("No image generated by AI model")
      }

      const processingId = `proc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

      const result: ProcessingResult = {
        success: true,
        resultImageUrl,
        processingId,
      }

      console.log(`Successfully processed hairstyle for processing ID: ${processingId}`)
      return NextResponse.json(result)
    } catch (replicateError: any) {
      console.error("Replicate API error:", replicateError)

      // Handle specific Replicate errors
      if (replicateError.message?.includes("insufficient credits")) {
        return NextResponse.json(
          { success: false, error: "AI service temporarily unavailable due to high demand" },
          { status: 503 },
        )
      }

      if (replicateError.message?.includes("rate limit")) {
        return NextResponse.json(
          { success: false, error: "Too many requests. Please try again in a moment." },
          { status: 429 },
        )
      }

      // Fallback to mock response for development/demo
      console.log("Falling back to mock response due to Replicate error")

      const mockResult: ProcessingResult = {
        success: true,
        resultImageUrl: "/placeholder.svg?height=400&width=400&text=AI+Generated+Result+(Demo)",
        processingId: `mock_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      }

      return NextResponse.json(mockResult)
    }
  } catch (error: any) {
    console.error("Processing error:", error)

    return NextResponse.json(
      {
        success: false,
        error: "Failed to process your image. Please try again.",
      },
      { status: 500 },
    )
  }
}

// Add OPTIONS handler for CORS if needed
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type",
    },
  })
}
